<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chaotic magnetic attraction</title>
    <style>
        body {
            display:block;
            margin:0;
        }
    </style>
</head>
<body>
    <canvas id="canvas" style="display: block; outline: lightblue 1px solid;">gbruh</canvas>

    <script>
        let context = canvas.getContext('2d');
        canvas/*.style*/.width = innerWidth;//+"px";
        canvas/*.style*/.height = innerHeight;//+"px";

        const Vector = {sub: function(left, right) {
            return new Vector2((right.x-left.x), (right.y-left.y));
        }, add: function(left, right) {
            return new Vector2((right.x+left.x), (right.y+left.y));
        }};

        class Vector2 {
            x = 0;
            y = 0;

            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            //add = function(right) {
            //    this.x = right.x + this.x;
            //    this.y = right.y + this.y;
            //    return this;
            //}

            getMagnitude = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            setMagnitude = function(newMag) {
                let Mag = this.getMagnitude();
                this.x *= newMag / Mag;
                this.y *= newMag / Mag;
            }
            divide = function(float) {
                this.x /= float;
                this.y /= float;
                return this;
            }

            //sub = function(right) {
            //    this.x = right.x - this.x;
            //    this.y = right.y - this.y;
            //    return this;
            //}
        }

        //well gah dayum if you use display block on your canvas that jawn will not bloat the dom up
        //well 1 2 buckle my shoe https://www.youtube.com/watch?v=zxGGMYZqJhk

        //context.fillRect(100,100, 200,200);

        let points = [{/*x: 400, y: 400*/position: new Vector2(400, 400), strength: 1}];
        let balls = [];
        let tempBall = {position: new Vector2(0,0)};

        let drag;

        function animate() {
            context.clearRect(0,0,innerWidth,innerHeight);

            for(let point of points) {
                context.beginPath();
                context.fillStyle = "blue";
                context.arc(point.position.x, point.position.y, 15, 0, 2 * Math.PI);
                context.fill()
            }

            context.beginPath();
            context.fillStyle = "rgba(128, 128, 128, .5)";
            context.arc(tempBall.position.x, tempBall.position.y, 10, 0, 2 * Math.PI);
            context.stroke();
            context.fill()

            for (let ball of balls) { //also apparently you can do let i in balls && let ball of balls[i] or somehait;
                //ball.x += ball.velocity.x; //can you override oporators in js if i wanted to use vector2 instead of {x,y} (well in threejs they just use functions sooo)
                //ball.y += ball.velocity.y;
                ball.position = Vector.add(ball.position, ball.velocity);
                context.beginPath();
                context.fillStyle = "grey";
                context.arc(ball.position.x, ball.position.y, 10, 0, 2 * Math.PI);
                context.stroke();
                context.fill();
                for(let point of points) {
                    let force = Vector.sub(ball.position, point.position);
                    let distanceSq = force.getMagnitude()**2;
                    let strength = point.strength * (100 * 100)/ distanceSq;
                    force.setMagnitude(strength);
                    ball.velocity = Vector.add(ball.velocity, force);
                    //let wholeMagnitude = Math.sqrt(((point.x-ball.x)**2) + ((point.y-ball.y)**2)); //shit this all i got
                    //console.log(wholeMagnitude);       //well according to coding train i was right about point.x-ball.x (which i have known this part works for a while) but what i was lacking was the magnitude, the force needed so F=G*(m1*m2)/d^2
                    //let F = point.strength*((100*100)/(wholeMagnitude**2));//{x: point.strength*((point.x-ball.x)/wholeMagnitude)*(100*100/(wholeMagnitude**2)), y: point.strength*((point.y-ball.y)/wholeMagnitude)*(100*100/(wholeMagnitude**2))} //damn im right
                    //let someshit = {x: (point.x-ball.x), y: (point.y-ball.y)};
                    //let final = {x: someshit.x * F / wholeMagnitude, y: someshit.x * F / wholeMagnitude};
                    //ball.velocity.x += final.x;//wholeMagnitude/(point.x-ball.x); //instead of whole magnitude i was using point.strength
                    //ball.velocity.y += final.y;//wholeMagnitude/(point.y-ball.y); //https://www.youtube.com/watch?v=GjbKsOkN1Oc
                }
            }

            requestAnimationFrame(animate);
        }

        addEventListener("mousedown", function(event) {
            tempBall = {position: new Vector2(event.clientX, event.clientY)};
            //balls.push({position: new Vector2(event.clientX,event.clientY), velocity: new Vector2(0,0)});//{x: event.clientX, y: event.clientY, velocity: {x: 0, y: 0}});
        });

        addEventListener("mouseup", function(event) {
            balls.push({position: /*new Vector2(event.clientX,event.clientY)*/tempBall.position, velocity: Vector.sub(new Vector2(event.clientX, event.clientY), tempBall.position).divide(10)});//{x: event.clientX, y: event.clientY, velocity: {x: 0, y: 0}});
            tempBall = {position: new Vector2(0,0)};
        });

        animate();
    </script>
</body>
</html>